@startuml
class App {
- {static} instance : App
+ catalog : Catalog
+ tickets : TicketBook
+ cashiers : CashierRegister
+ customers : CustomerRegister
- handlers : RequestHandler[]
- commands : HashMap<String, Consumer<Request>>
- input : InputDriver
- config : Config
- App()
+ {static} getInstance() : App
+ init(inputFile : String)
+ {static} main(String[])
- handleRequest(request : Request)
- execute(Action, Request)
- echo(Request)
- help()
- exit()
}

class InputDriver {
- input : Scanner
+ InputDriver()
+ InputDriver(file : String)
+ next() : Request
}

App *-- InputDriver

package Requests {

class Request {
+ handlerId : String
+ actionId : String
+ args : String[]
+ Request(line : String)
- tokenize(line : String) : ArrayList<String>
}

Request <-- InputDriver : Creates

abstract RequestHandler {
+ HANDLER_ID : String
- actions : HashMap<actionId : String, Action>
+ RequestHandler(handlerId)
+ getAction(Request) : Action
+ getActions() : HashMap<actionId : String, Action>
}

RequestHandler <|-- CustomerHandler
RequestHandler <|-- CashierHandler
RequestHandler <|-- TicketHandler
RequestHandler <|-- ProductHandler

}
' Requests

App *-- "0...n" RequestHandler

Action <-- App : Executes
RequestHandler *-- "0..n" Action
Request <-- RequestHandler: Receives

note left of Action : Several classes implement Action,\nthese are the ones with the code that\nexecutes the orders of the user
interface Action {
+ Action()
+ {abstract} exec(String[]) : int
+ {abstract} help()
}

package ProductContainer {

class Catalog {
- products : HashMap<productId : int, BaseProduct>
- MAX_PRODUCTS : int
+ Catalog()
+ getProduct(id) : BaseProduct
+ getProducts() : HashMap<productId : int, BaseProduct>
+ add(BaseProduct) : int
+ getNewId() : int
+ deleteProduct(id) : BaseProduct
+ existsId(id) : boolean
}

App *-- Catalog

package ProductTypes {

abstract class BaseProduct {
- id : int
- name : String
- price : double
+ BaseProduct(id, name, price)
}

Catalog o-- "0...n" BaseProduct

class Product {
- category : Category
+ Product(category)
}

BaseProduct <|-- Product

class CustomProduct {
- maxPers : int
- personalizations : ArrayList<String>
+ CustomProduct(maxPers)
}

Product <|-- CustomProduct

class Event {
- expireDate : LocalDate
- maxPeople : int
- actualPeople : int
- MAX_PEOPLE_ALLOWED : int
- type : EventType
+ Event(expireDate, maxPeople, eventType)
}

BaseProduct <|-- Event

package ProductEnums {

enum EventType {
FOOD(72)
MEETING(12)
- planningTime : int
+ EventType(planningTime : int)
+ getPlanningTime() : int
{static} + toSentenceCase() : String
}

enum Category {
MERCH(0)
STATIONERY(5)
CLOTHES(7)
BOOK(10)
ELECTRONICS(3)
- discount : double
+ Category(discount : double)
+ getDiscount() : double
+ getCategories() : String
+ getCategoriesWithDiscount() : String
}

}

}

}

package UserContainer {

abstract UserRegister <T extends User> {
+ USER_TYPE : String
- users: HashMap<userId: String, T>
+ UserRegister(userType)
+ getUser(userId) : User
+ add(User) : int
+ removeUser(userId) : int
+ getUsers() : User[]
}

UserRegister <|-- CashierRegister
UserRegister <|-- CustomerRegister

App *-- CustomerRegister
App *-- CashierRegister

abstract User {
+ TYPE : String
- id : String
- name : String
- email : Email
+ User(name, email)
}

UserRegister o-- "0...n" User

class Email {
- username : String
- domain : String
+ Email(username, domain)
}

User *-- Email

class Customer {
- cashId : String
+ Customer(cashierId)
}

User <|-- Customer
User <|-- Cashier

}

package TicketContainer {

class TicketBook {
- tickets : Hashmap<ticketId : int, ticketEntry : TicketEntry>
- userToTicket : Hashmap<userId : String, ticketIds : String[]>
+ TicketBook()
+ getTicket(ticketId) : Ticket
+ addNewTicket(ticketId, cashId, customerId) : int
+ getTickets() : Hashmap<ticketId : int, TicketEntry>
+ getTicketsFromUser(userId) : Hashmap<ticketId : int, TicketEntry>
+ getOpenedTicketsWithProd(prodId) : ArrayList<Ticket>
+ listTicketsSortedByCashierId(cashId) : List<TicketEntry>
+ getTicketIfCashierMatches(tickedId : String, cashId : String) : Ticket
+ addProductToTicket(ticketId, cashId, BaseProduct, amount, personalizations : ArrayList<String>) : int
+ removeProduct(ticketId, cashId, prodId) : int
+ getTicketsFrom(userId) : List<TicketEntry>
+ removeTicketsFrom(userId) : int
}

App *-- TicketBook

struct TicketEntry {
+ cashId : String
+ customerId : String
+ ticket : Ticket
}

TicketBook *-- "0...n" TicketEntry

class Ticket {
- {static} MAX_PRODUCTS_PER_TICKET : int
- ticketState : TicketState
- entries: HashMap<productId : int, ProductEntry>
- categories : HashMap<Category, amount: int>
- creationDate : LocalDateTime
- closingDate : LocalDateTime
- ticketId : String
- printedOutput : String
+ Ticket()
+ Ticket(ticketId)
+ addProduct(BaseProduct, amount) : int
+ addProduct(CustomProduct, amount, edits ArrayList<String>) : int
+ deleteProduct(prodId) : int
+ updateProduct(prodId) : int
+ printTicket() : void
+ 
+ hasProduct(prodId) : boolean
+ isClosed() : boolean
}

TicketEntry *-- Ticket

struct ProductEntry {
+ product : BaseProduct
+ amount : int;
+ unitPriceSnapshot : double;
+ categorySnapshot : Category;
}

Ticket o-- ProductEntry
ProductEntry o-- BaseProduct

}

@enduml
